
- typed metas
- ordered metacontext
- pruning                -- BUGGY


previously we had:

meta solutions: mutual top-level definitions (untyped)

let ?0 = ?1   -- solved with ?1
let ?1 = ?    -- unsolved

-- more important if we have non-normal solutions (glued evaluation)

let ?0 = .........
let ?1 = ..... ?0 ......

-- we also want elaboration output to be easily validated by core type checking
-- mutual definitions is *not* a conventional feature of a core TT

-- Ordered context: more efficient: occurs checking more efficient (with non-normal solutions)

-- question: ?1 occurs in ?0 x y z      (skip unfolding 0? during occurs checking)


-- Typed metas?
------------------------------------------------------------

- also need type annotation for validation of output
- algorithms requires known types of metas


-- Pruning
------------------------------------------------------------

Inserted meta:
   ... ?α x y z ...

We can learn that ?α cannot depend on all of its parameters
  -> immediately solve ?α with a fresh meta, which depends on fewer params

example:

  ?α =? (?β x y → Bool)   -- without pruning: failure (solution cannot depend on x, y)

with pruning: there's only a solution to above if ?β does not depend on x,y

    ?β x y : fresh ?β',
    solve ?β = λ x y. ?β'

we have to check that (?β = λ x y. ?β') is well-typed

-- ?β : (n m : Nat) → Vec n Bool → Vec m Bool
-- ?β = λ n m. ?β'  (not well-typed for any closed ?β')

-- we have to prune the type of ?β

-- ?β : (a : A)(b : B a) → C a b
--    -- if we want to drop (a, b), then we have to check that C a b is valid in the empty context
--    -- if we only want to drop a, B a has to be closed, C a b only depends on b

simple use case for pruning:

  let g = λ f x. f x;

     -- f has type ?0
     -- x has type (?1 f)
     -- infer ?0 for f
     --   ?0 =? (a : ?2 f x) → ?3 f x a        -- requires pruning
     --   ?0 =? (a : ?2') → ?3' a              -- ?2, ?3 pruned
     -- (we know ?2 : _ → _ → U)
     -- (we know ?3 : _ → _ → _ → U)


-- intersections (additional use case of pruning)
------------------------------------------------------------

?α spine = ?α spine'

-- spine and spine' are both renamings (only contain bound vars)
-- ?α only has a solution, if it depends only on spine entries which are the same

example:

  ?α x x y =? ?α z x z    (prune first and third arguments)

  ?α = λ x y z. ?α' y     (check well-typedness of pruning)


-- pruning of nonlinear arguments
--------------------------------------------------------------------------------

  ?α x x =? rhs       (previously: failure)

  - try to prune non-linear arguments form α
  - retry unification

  - (if we have postponing, then we can postpone, and solve without pruning, possibly)
  - (extend partial renaming of rhs to handle non-linear occurrences)


-- implementation of ordered metacontexts
--------------------------------------------------------------------------------

-- efficient
-- (order-maintenance data structure)
-- total order on metas, two operations:
--  1. efficient query on ordering,
--  2. strengthening (moving back some meta before some other meta)
--  3. push a new meta to the end of the context

-- folklore:

-- (?0, w₀),   (?1, w₁),    (?2, w₂)


--  (?0, 5) ---> (?3, 6) --> (?1, 10)  --> (?fresh, 11)
--   insertion: take the average of weights
--              (if I run out of precision, I just reassign weights for all entries)

-- putting ?1 between ?0 and ?3:

-- (?0, 5) ---> (?1, 5.5) --> (?3, 6) --> (?fresh, 11)


--------------------------------------------------------------------------------

-- metacontext interleaved with usual context
--  (order-maintenance structure as before)

-- fresh meta goes to end of the scope

-- scope checking is relative the position of m in the scope
--    top-level: ?0 spine =? rhs     (strengthen rhs to spine)
--                                   (?0 depends on spine + every bound var in scope of ?0)

-- elaborate under binder:

-- check Γ (λ x. t) ((x : A) → B)

-- check (Γ, x : A) t B  returns  t' in (Γ', x : A, Δ)     (Δ contains new metas, Γ')
--    we want to return (λ x. t')
--    I have to eliminate Δ, and get some (Γ', x : A ⊢ t')

--   every solved meta in Δ becomes a let definition
--   every unsolved meta in Δ is generalized over (x : A) (also becomes a let-definition)

--   t', Δ = α : Bool = ?, β : Bool = ?

--  t'' := let α : Bool = α' x; β : Bool = β' x; in t'
--  Γ'' := Γ', α' : A → Bool, β' : A → Bool

-- return (λ x. t'') which is valid in Γ''

-- (quite complicated with glued evaluation)


--------------------------------------------------------------------------------
-- Top-level glue
