
-- preliminary types and definitions
------------------------------------------------------------

λ (List   : U → U)
  (Bool   : U)
  (ST     : U → U → U)
  (Pair   : U → U → U)
  (pair   : {A B} → A → B → Pair A B)
  (true   : Bool)
  (Int    : U)
  (zero   : Int)
  (inc    : Int → Int)
  (head   : {A} → List A → A)
  (tail   : {A} → List A → List A)
  (nil    : {A} → List A)
  (cons   : {A} → A → List A → List A)
  (append : {A} → List A → List A → List A)
  (length : {A} → List A → Int)
  (map    : {A B} → (A → B) → List A → List B)
  (runST  : {A} → ({S} → ST S A) → A)
  (argST  : {S} → ST S Int).


let the    : (A : U) → A → A         = λ A a. a;
let const  : {A B} → A → B → A       = λ x y. x;
let IdTy   : U                       = {A} → A → A;
let single : {A} → A → List A        = λ a. cons a nil;
let id     : {A} → A → A             = λ a. a;
let ids    : List IdTy               = nil;
let app    : {A B} → (A → B) → A → B = id;
let revapp : {A B} → A → (A → B) → B = λ x f. f x;
let poly   : IdTy → Pair Int Bool    = λ f. pair (f zero) (f true);
let choose : {A} → A → A → A         = const;
let auto   : IdTy → IdTy             = id;
let auto2  : {B} → IdTy → B → B      = λ _ b. b;


-- Table
--------------------------------------------------------------------------------

-- A: polymorphic instantiation
--------------------------------------------------------------------------------

-- No generalization
let A1 = λ x y. y;

-- No generalization
let A2 : IdTy → IdTy = choose id;

let A3 = choose nil ids;

-- No generalization
let A4 : IdTy → IdTy = λ (x : IdTy). x x;

let A5 = id auto;

-- No generalization
let A6 : {B} → IdTy → B → B = id auto2;

let A7 = choose id auto;

-- let A8 = choose id auto2 in -- FAILS the reason is simply that the types are
--   definitionally different, the orders of implicit args do not match. We
--   do *not* reorder or float out implicit args, intentionally, since we
--   support mixing implicit and explicit args in arbitrary order.

-- No generalization
let A9 : ({A} → (A → A) → List A → A) → IdTy
    = λ f. f (choose id) ids;

let A10 = poly id;

let A11 = poly (λ x. x);

let A12 = id poly (λ x. x);

-- B: inference of polymorphic arguments
--------------------------------------------------------------------------------

-- FAILS
-- let B1 = λ f. pair (f zero) (f true);

-- FAILS
-- let B2 = λ xs. poly (head xs);
  -- however, it could possibly work with telescope application insertion + postponing


-- C: functions on polymorphic lists
--------------------------------------------------------------------------------

let C1 = length ids;

let C2 = tail ids;

-- No generalization
let C3 : IdTy = head ids;

-- No generalization
let C4 : List IdTy = single id;

let C5 = cons id ids;

let C6 = cons (λ x. x) ids;

let C7 = append (single inc) (single id);

-- No generalization
let C8 : _ → IdTy = λ (g : {A} → List A → List A → A). g (single id) ids;

let C9 = map poly (single id);

let C10 = map head (single ids);

-- -- D: application functions
-- --------------------------------------------------------------------------------

let D1 = app poly id;

let D2 = revapp id poly;

let D3 = runST argST;

let D4 = app runST argST;

let D5 = revapp argST runST;

-- E: η-expansion
--------------------------------------------------------------------------------

-- let E1 =   -- FAILS
--   λ (h : Int → {A} → A → A)(k : {A} → A → List A → A)(lst : List ({A} → Int → A → A)).
--   k h lst;
--   -- fails again because of mismatched implicit/explicit arguments

-- No generalization
let E2 =
  λ (h : Int → {A} → A → A)(k : {A} → A → List A → A)(lst : List ({A} → Int → A → A)).
  k (λ x. h x) lst;

let E3 =
  λ (r : ({A} → A → {B} → B → B) → Int). r (λ x y. y);

U
